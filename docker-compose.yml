services:
  postgres:
    image: postgres:15
    container_name: taskflow-postgres
    environment:
      POSTGRES_USER: taskflow
      POSTGRES_PASSWORD: taskflow
      POSTGRES_DB: authdb
      POSTGRES_HOST_AUTH_METHOD: trust
    ports:
      - "5433:5432" # Host port 5433 mapped to container port 5432
    volumes:
      - pgdata:/var/lib/postgresql/data
    networks:
      - taskflow-net
    # RECOMMENDED FIX: Healthcheck to ensure the DB is ready before the app starts
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U taskflow -d authdb"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7
    container_name: taskflow-redis
    ports:
      - "6379:6379"
    networks:
      - taskflow-net

  auth-service:
    build:
      context: ./auth-service
      dockerfile: Dockerfile
    container_name: auth-service
    # NOTE: Application port should match your container port setup (8081 in this case)
    ports:
      - "8081:8081"
    environment:
      - JWT_SECRET=yourSuperLongAndSecureSecretKeyAtLeast32Chars!!
      - JWT_REFRESH_SECRET=anotherVeryLongAndSecureRefreshSecretKey32Chars!!
      - spring.datasource.url=jdbc:postgresql://postgres:5432/authdb
      - spring.datasource.username=taskflow
      - spring.datasource.password=taskflow

      # Recommended replacement for old 'SPRING_JPA_HIBERNATE_DDL_AUTO' for schema initialization
      - spring.sql.init.mode=always 

    # Use the healthcheck from the postgres service to guarantee DB readiness
    depends_on:
      postgres:
        condition: service_healthy 
      
    networks:
      - taskflow-net

  gateway-service:
    build:
      context: ./gateway-service/
      dockerfile: Dockerfile
    container_name: gateway-service
    ports:
      - "8080:8080"
    environment:
      - JWT_SECRET=yourSuperSecretKey
    depends_on:
      - auth-service
      - redis
    networks:
      - taskflow-net

  # user-service:
  #   build:
  #     context: ./user-service
  #     dockerfile: Dockerfile
  #   container_name: user-service
  #   ports:
  #     - "8082:8082"
  #   environment:
  #     - server.port=8082
  #     - spring.r2dbc.url=r2dbc:postgresql://user-postgres:5432/userdb
  #     - spring.r2dbc.username=taskflow
  #     - spring.r2dbc.password=taskflow
  #     - spring.sql.init.mode=always
  #     - aws.sqs.user-created-queue=user-created-queue
  #     - spring.cloud.aws.region.static=us-east-1
  #     - spring.cloud.aws.credentials.access-key=test
  #     - spring.cloud.aws.credentials.secret-key=test
  #     - spring.cloud.aws.endpoint.sqs=http://localstack:4566
  #   depends_on:
  #     localstack:
  #       condition: service_started
  #     user-postgres:
  #       condition: service_healthy
  #   networks:
  #     - taskflow-net

  # user-postgres:
  #   image: postgres:15
  #   container_name: user-postgres
  #   environment:
  #     POSTGRES_USER: taskflow
  #     POSTGRES_PASSWORD: taskflow
  #     POSTGRES_DB: userdb
  #     POSTGRES_HOST_AUTH_METHOD: trust
  #   ports:
  #     - "5434:5432"
  #   volumes:
  #     - userpgdata:/var/lib/postgresql/data
  #   networks:
  #     - taskflow-net
  #   healthcheck:
  #     test: ["CMD-SHELL", "pg_isready -U taskflow -d userdb"]
  #     interval: 5s
  #     timeout: 5s
  #     retries: 5

  localstack:
    image: localstack/localstack:3.0
    container_name: taskflow-localstack
    ports:
      - "4566:4566"
    environment:
      - SERVICES=sqs,sns
      - DEBUG=1
      - AWS_DEFAULT_REGION=us-east-1
    volumes:
      - localstack-data:/var/lib/localstack
    networks:
      - taskflow-net


volumes:
  pgdata:
  userpgdata:
  localstack-data:

networks:
  taskflow-net: