services:
  postgres:
    image: postgres:15
    container_name: taskflow-postgres
    environment:
      POSTGRES_USER: taskflow
      POSTGRES_PASSWORD: taskflow
      POSTGRES_DB: authdb
      POSTGRES_HOST_AUTH_METHOD: trust
    ports:
      - "5433:5432" # Host port 5433 mapped to container port 5432
    volumes:
      - pgdata:/var/lib/postgresql/data
    networks:
      - taskflow-net
    # RECOMMENDED FIX: Healthcheck to ensure the DB is ready before the app starts
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U taskflow -d authdb"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7
    container_name: taskflow-redis
    ports:
      - "6379:6379"
    networks:
      - taskflow-net

  auth-service:
    build:
      context: ./auth-service
      dockerfile: Dockerfile
    container_name: auth-service
    # NOTE: Application port should match your container port setup (8081 in this case)
    ports:
      - "8081:8081"
    environment:
      - JWT_SECRET=${JWT_SECRET}
      - JWT_REFRESH_SECRET=${JWT_REFRESH_SECRET}
      - spring.datasource.url=jdbc:postgresql://postgres:5432/authdb
      - spring.datasource.username=taskflow
      - spring.datasource.password=taskflow

      # Recommended replacement for old 'SPRING_JPA_HIBERNATE_DDL_AUTO' for schema initialization
      - spring.sql.init.mode=always 

    # Use the healthcheck from the postgres service to guarantee DB readiness
    depends_on:
      postgres:
        condition: service_healthy 
      
    networks:
      - taskflow-net

  gateway-service:
    build:
      context: ./gateway-service/
      dockerfile: Dockerfile
    container_name: gateway-service
    ports:
      - "8080:8080"
    environment:
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - auth-service
      - redis
    networks:
      - taskflow-net

  # user-service:
  #   build:
  #     context: ./user-service
  #     dockerfile: Dockerfile
  #   container_name: user-service
  #   ports:
  #     - "8082:8082"
  #   environment:
  #     - server.port=8082
  #     - spring.r2dbc.url=r2dbc:postgresql://user-postgres:5432/userdb
  #     - spring.r2dbc.username=taskflow
  #     - spring.r2dbc.password=taskflow
  #     - spring.sql.init.mode=always
  #     - aws.sqs.user-created-queue=user-created-queue
  #     - spring.cloud.aws.region.static=us-east-1
  #     - spring.cloud.aws.credentials.access-key=test
  #     - spring.cloud.aws.credentials.secret-key=test
  #     - spring.cloud.aws.endpoint.sqs=http://localstack:4566
  #   depends_on:
  #     localstack:
  #       condition: service_started
  #     user-postgres:
  #       condition: service_healthy
  #   networks:
  #     - taskflow-net

  # user-postgres:
  #   image: postgres:15
  #   container_name: user-postgres
  #   environment:
  #     POSTGRES_USER: taskflow
  #     POSTGRES_PASSWORD: taskflow
  #     POSTGRES_DB: userdb
  #     POSTGRES_HOST_AUTH_METHOD: trust
  #   ports:
  #     - "5434:5432"
  #   volumes:
  #     - userpgdata:/var/lib/postgresql/data
  #   networks:
  #     - taskflow-net
  #   healthcheck:
  #     test: ["CMD-SHELL", "pg_isready -U taskflow -d userdb"]
  #     interval: 5s
  #     timeout: 5s
  #     retries: 5

  localstack:
    image: localstack/localstack:3.0
    container_name: taskflow-localstack
    ports:
      - "4566:4566"
    environment:
      - SERVICES=sqs,sns
      - DEBUG=1
      - AWS_DEFAULT_REGION=us-east-1
    volumes:
      - localstack-data:/var/lib/localstack
    networks:
      - taskflow-net

  # --- Observability Stack ---

  prometheus:
    image: prom/prometheus:v2.51.0
    container_name: taskflow-prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./observability/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus-data:/prometheus
    depends_on:
      - auth-service
    networks:
      - taskflow-net

  tempo:
    image: grafana/tempo:2.4.1
    container_name: taskflow-tempo
    command: ["-config.file=/etc/tempo/tempo.yml"]
    ports:
      - "3200:3200"
      - "4317:4317"
      - "4318:4318"
    volumes:
      - ./observability/tempo/tempo.yml:/etc/tempo/tempo.yml:ro
      - tempo-data:/var/tempo
    networks:
      - taskflow-net

  loki:
    image: grafana/loki:2.9.4
    container_name: taskflow-loki
    command: ["-config.file=/etc/loki/loki.yml"]
    ports:
      - "3100:3100"
    volumes:
      - ./observability/loki/loki.yml:/etc/loki/loki.yml:ro
      - loki-data:/loki
    networks:
      - taskflow-net

  promtail:
    image: grafana/promtail:2.9.4
    container_name: taskflow-promtail
    command: ["-config.file=/etc/promtail/promtail.yml"]
    volumes:
      - ./observability/promtail/promtail.yml:/etc/promtail/promtail.yml:ro
      - //var/run/docker.sock:/var/run/docker.sock:ro
    depends_on:
      - loki
    networks:
      - taskflow-net

  grafana:
    image: grafana/grafana:10.4.1
    container_name: taskflow-grafana
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - ./observability/grafana/provisioning:/etc/grafana/provisioning:ro
      - grafana-data:/var/lib/grafana
    depends_on:
      - prometheus
      - loki
      - tempo
    networks:
      - taskflow-net


volumes:
  pgdata:
  userpgdata:
  localstack-data:
  prometheus-data:
  tempo-data:
  loki-data:
  grafana-data:

networks:
  taskflow-net: